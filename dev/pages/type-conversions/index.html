<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Type Conversions · LibPQ.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LibPQ.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li class="is-active"><a class="tocitem" href>Type Conversions</a><ul class="internal"><li><a class="tocitem" href="#From-Julia-to-PostgreSQL"><span>From Julia to PostgreSQL</span></a></li><li><a class="tocitem" href="#From-PostgreSQL-to-Julia"><span>From PostgreSQL to Julia</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Type Conversions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Type Conversions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/invenia/LibPQ.jl/blob/master/docs/src/pages/type-conversions.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="typeconv"><a class="docs-heading-anchor" href="#typeconv">Type Conversions</a><a id="typeconv-1"></a><a class="docs-heading-anchor-permalink" href="#typeconv" title="Permalink"></a></h1><p>The implementation of type conversions across the LibPQ.jl interface is sufficiently complicated that it warrants its own section in the documentation. Luckily, it should be easy to <em>use</em> for whichever case you need.</p><h2 id="From-Julia-to-PostgreSQL"><a class="docs-heading-anchor" href="#From-Julia-to-PostgreSQL">From Julia to PostgreSQL</a><a id="From-Julia-to-PostgreSQL-1"></a><a class="docs-heading-anchor-permalink" href="#From-Julia-to-PostgreSQL" title="Permalink"></a></h2><p>Currently all types are printed to strings and given to LibPQ as such, with no special treatment. Expect this to change in a future release. For now, you can convert the data to strings yourself before passing to <a href="../api/#LibPQ.execute"><code>execute</code></a>. This should only be necessary for data types whose Julia string representation is not valid in PostgreSQL, such as arrays.</p><pre><code class="language-julia-repl">julia&gt; A = collect(12:15);

julia&gt; nt = columntable(execute(conn, &quot;SELECT \$1 = ANY(\$2) AS result&quot;, Any[13, string(&quot;{&quot;, join(A, &quot;,&quot;), &quot;}&quot;)]));

julia&gt; nt[:result][1]
true</code></pre><h2 id="From-PostgreSQL-to-Julia"><a class="docs-heading-anchor" href="#From-PostgreSQL-to-Julia">From PostgreSQL to Julia</a><a id="From-PostgreSQL-to-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#From-PostgreSQL-to-Julia" title="Permalink"></a></h2><p>The default type conversions applied when fetching PostgreSQL data should be sufficient in many cases.</p><pre><code class="language-julia">julia&gt; df = DataFrame(execute(conn, &quot;SELECT 1::int4, &#39;foo&#39;::varchar, &#39;{1.0, 2.1, 3.3}&#39;::float8[], false, TIMESTAMP &#39;2004-10-19 10:23:54&#39;&quot;))
1×5 DataFrames.DataFrame
│ Row │ int4 │ varchar │ float8          │ bool  │ timestamp           │
├─────┼──────┼─────────┼─────────────────┼───────┼─────────────────────┤
│ 1   │ 1    │ foo     │ [1.0, 2.1, 3.3] │ false │ 2004-10-19T10:23:54 │</code></pre><p>The column types in Julia for the above DataFrame are <code>Int32</code>, <code>String</code>, <code>Vector{Float64}</code>, <code>Bool</code>, and <code>DateTime</code>.</p><p>Any unknown or unsupported types are parsed as <code>String</code>s by default.</p><h3 id="NULL"><a class="docs-heading-anchor" href="#NULL"><code>NULL</code></a><a id="NULL-1"></a><a class="docs-heading-anchor-permalink" href="#NULL" title="Permalink"></a></h3><p>The PostgreSQL <code>NULL</code> is handled with <code>missing</code>. By default, data streamed using the Tables interface is <code>Union{T, Missing}</code>, and columns are <code>Vector{Union{T, Missing}}</code>. While <code>libpq</code> does not provide an interface for checking whether a result column contains <code>NULL</code>, it&#39;s possible to assert that columns do not contain <code>NULL</code> using the <code>not_null</code> keyword argument to <a href="../api/#LibPQ.execute"><code>execute</code></a>. This will result in data retrieved as <code>T</code>/<code>Vector{T}</code> instead. <code>not_null</code> accepts a list of column names or column positions, or a <code>Bool</code> asserting that all columns do or do not have the possibility of <code>NULL</code>.</p><p>The type-related interfaces described below only deal with the <code>T</code> part of the <code>Union{T, Missing}</code>, and there is currently no way to use an alternate <code>NULL</code> representation.</p><h3 id="Overrides"><a class="docs-heading-anchor" href="#Overrides">Overrides</a><a id="Overrides-1"></a><a class="docs-heading-anchor-permalink" href="#Overrides" title="Permalink"></a></h3><p>It&#39;s possible to override the default type conversion behaviour in several places. Refer to the <a href="#Implementation">Implementation</a> section for more detailed information.</p><h4 id="Query-level"><a class="docs-heading-anchor" href="#Query-level">Query-level</a><a id="Query-level-1"></a><a class="docs-heading-anchor-permalink" href="#Query-level" title="Permalink"></a></h4><p>There are three arguments to <a href="../api/#LibPQ.execute"><code>execute</code></a> for this:</p><ul><li><code>column_types</code> argument to set the desired types for given columns. This is accepted as a dictionary mapping column names (as <code>Symbol</code>s or <code>String</code>s) and/or positions (as <code>Integer</code>s) to Julia types.</li><li><code>type_map</code> argument to set the mapping from PostgreSQL types to Julia types. This is accepted as a dictionary mapping PostgreSQL oids (as <code>Integer</code>s) or <a href="#canon">canonical</a> type names (as <code>Symbol</code>s or <code>String</code>s) to Julia types.</li><li><code>conversions</code> argument to set the <em>function</em> used to convert from a given PostgreSQL type to a given Julia type. This is accepted as a dictionary mapping 2-tuples of PostgreSQL oids or type names (as above) and Julia types to callables (functions or type constructors).</li></ul><h4 id="Connection-level"><a class="docs-heading-anchor" href="#Connection-level">Connection-level</a><a id="Connection-level-1"></a><a class="docs-heading-anchor-permalink" href="#Connection-level" title="Permalink"></a></h4><p><a href="../api/#LibPQ.Connection"><code>LibPQ.Connection</code></a> supports <code>type_map</code> and <code>conversions</code> arguments as well, which will apply to all queries run with the created connection. Query-level overrides will override connection-level overrides.</p><h4 id="Global"><a class="docs-heading-anchor" href="#Global">Global</a><a id="Global-1"></a><a class="docs-heading-anchor-permalink" href="#Global" title="Permalink"></a></h4><p>To override behaviour for every query everywhere, add mappings to the global constants <a href="../api/#LibPQ.LIBPQ_TYPE_MAP"><code>LibPQ.LIBPQ_TYPE_MAP</code></a> and <a href="../api/#LibPQ.LIBPQ_CONVERSIONS"><code>LibPQ.LIBPQ_CONVERSIONS</code></a>. Connection-level overrides will override these global overrides.</p><h3 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h3><h4 id="Flow"><a class="docs-heading-anchor" href="#Flow">Flow</a><a id="Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Flow" title="Permalink"></a></h4><p>When a <a href="../api/#LibPQ.Result"><code>LibPQ.Result</code></a> is created (as the result of running a query), the Julia types and conversion functions for each column are precalculated and stored within the <code>Result</code>. The types are chosen using these sources, in decreasing priority:</p><ul><li><code>column_types</code> overrides at <code>Result</code> level</li><li><code>type_map</code> overrides at <code>Result</code> level</li><li><code>type_map</code> overrides at <code>Connection</code> level</li><li><a href="../api/#LibPQ.LIBPQ_TYPE_MAP"><code>LibPQ.LIBPQ_TYPE_MAP</code></a></li><li><a href="../api/#LibPQ._DEFAULT_TYPE_MAP"><code>LibPQ._DEFAULT_TYPE_MAP</code></a></li><li>fallback to <code>String</code></li></ul><p>Using those types, the function for converting from PostgreSQL data to Julia data is selected, using these sources, in decreasing priority:</p><ul><li><code>conversions</code> overrides at <code>Result</code> level</li><li><code>conversions</code> overrides at <code>Connection</code> level</li><li><a href="../api/#LibPQ.LIBPQ_CONVERSIONS"><code>LibPQ.LIBPQ_CONVERSIONS</code></a></li><li><a href="../api/#LibPQ._DEFAULT_CONVERSIONS"><code>LibPQ._DEFAULT_CONVERSIONS</code></a>,</li><li>fallback to <code>parse</code></li></ul><p>When fetching a particular value from a <code>Result</code>, that function is used to turn data wrapped by a <code>PQValue</code> to a Julia type. This operation always copies or parses data and never provides a view into the original <code>Result</code>.</p><h4 id="canon"><a class="docs-heading-anchor" href="#canon">Canonical PostgreSQL Type Names</a><a id="canon-1"></a><a class="docs-heading-anchor-permalink" href="#canon" title="Permalink"></a></h4><p>While PostgreSQL allows many aliases for its types (e.g., <code>double precision</code> for <code>float8</code> and <code>character varying</code> for <code>varchar</code>), there is one &quot;canonical&quot; name for the type stored in the <code>pg_type</code> table from PostgreSQL&#39;s catalog. You can find a list of these for all of PostgreSQL&#39;s default types in the keys of <a href="../api/#LibPQ.PQ_SYSTEM_TYPES"><code>LibPQ.PQ_SYSTEM_TYPES</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../api/">API »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 6 October 2021 22:10">Wednesday 6 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
