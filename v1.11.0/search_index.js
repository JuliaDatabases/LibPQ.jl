var documenterSearchIndex = {"docs":
[{"location":"pages/api/#LibPQ-API","page":"API","title":"LibPQ API","text":"","category":"section"},{"location":"pages/api/#Public","page":"API","title":"Public","text":"","category":"section"},{"location":"pages/api/#Connections","page":"API","title":"Connections","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.Connection\nexecute\nprepare\nstatus(::LibPQ.Connection)\nBase.close(::LibPQ.Connection)\nBase.isopen(::LibPQ.Connection)\nreset!(::LibPQ.Connection)\nBase.show(::IO, ::LibPQ.Connection)","category":"page"},{"location":"pages/api/#LibPQ.Connection","page":"API","title":"LibPQ.Connection","text":"mutable struct Connection\n\nA connection to a PostgreSQL database.\n\nFields:\n\nconn::Ptr{Nothing}\nA pointer to a libpq PGconn object (C_NULL if closed)\nencoding::String\nlibpq client encoding (string encoding of returned data)\nuid_counter::UInt64\nInteger counter for generating connection-level unique identifiers\ntype_map::LibPQ.PQTypeMap\nConnection-level type correspondence map\nfunc_map::LibPQ.PQConversions\nConnection-level conversion functions\nclosed::Base.Threads.Atomic{Bool}\nTrue if the connection is closed and the PGconn object has been cleaned up\nsemaphore::Base.Semaphore\nSemaphore for thread-safety (not thread-safe until Julia 1.2)\nasync_result::Any\nCurrent AsyncResult, if active\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.execute","page":"API","title":"LibPQ.execute","text":"execute(\n    {jl_conn::Connection, query::AbstractString | stmt::Statement},\n    [parameters::Union{AbstractVector, Tuple},]\n    throw_error::Bool=true,\n    binary_format::Bool=false,\n    column_types::AbstractDict=ColumnTypeMap(),\n    type_map::AbstractDict=LibPQ.PQTypeMap(),\n    conversions::AbstractDict=LibPQ.PQConversions(),\n) -> Result\n\nRun a query on the PostgreSQL database and return a Result. If throw_error is true, throw an error and clear the result if the query results in a fatal error or unreadable response.\n\nThe query may be passed as Connection and AbstractString (SQL) arguments, or as a Statement.\n\nexecute optionally takes a parameters vector which passes query parameters as strings to PostgreSQL.\n\ncolumn_types accepts type overrides for columns in the result which take priority over those in type_map. For information on the column_types, type_map, and conversions arguments, see Type Conversions.\n\nbinary_format, when set to true, will transfer the data in binary format. Support for binary transfer is currently limited to a subset of basic data types.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.prepare","page":"API","title":"LibPQ.prepare","text":"prepare(jl_conn::Connection, query::AbstractString) -> Statement\n\nCreate a prepared statement on the PostgreSQL server using libpq. The statement is given an generated unique name using unique_id.\n\nnote: Note\nCurrently the statement is not explicitly deallocated, but it is deallocated at the end of session per the PostgreSQL documentation on DEALLOCATE.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.status-Tuple{LibPQ.Connection}","page":"API","title":"LibPQ.status","text":"status(jl_conn::Connection) -> libpq_c.ConnStatusType\n\nReturn the status of the PostgreSQL database connection according to libpq. Only CONNECTION_OK and CONNECTION_BAD are valid for blocking connections, and only blocking connections are supported right now.\n\nSee also: error_message\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Base.close-Tuple{LibPQ.Connection}","page":"API","title":"Base.close","text":"close(jl_conn::Connection)\n\nClose the PostgreSQL database connection and free the memory used by the PGconn object. This function calls PQfinish, but only if jl_conn.closed is false, to avoid a double-free.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Base.isopen-Tuple{LibPQ.Connection}","page":"API","title":"Base.isopen","text":"isopen(jl_conn::Connection) -> Bool\n\nCheck whether a connection is open.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LibPQ.reset!-Tuple{LibPQ.Connection}","page":"API","title":"LibPQ.reset!","text":"reset!(jl_conn::Connection; throw_error=true)\n\nReset the communication to the PostgreSQL server. The PGconn object will be recreated using identical connection parameters.\n\nSee handle_new_connection for information on the throw_error argument.\n\nnote: Note\nThis function can be called on a connection with status CONNECTION_BAD, for example, but cannot be called on a connection that has been closed.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Base.show-Tuple{IO, LibPQ.Connection}","page":"API","title":"Base.show","text":"show(io::IO, jl_conn::Connection)\n\nDisplay a Connection by showing the connection status and each connection option.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Results","page":"API","title":"Results","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.Result\nstatus(::LibPQ.Result)\nBase.close(::LibPQ.Result)\nBase.isopen(::LibPQ.Result)\nnum_rows(::LibPQ.Result)\nnum_columns(::LibPQ.Result)\nnum_affected_rows(::LibPQ.Result)\nBase.show(::IO, ::LibPQ.Result)","category":"page"},{"location":"pages/api/#LibPQ.Result","page":"API","title":"LibPQ.Result","text":"A result from a PostgreSQL database query\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.status-Tuple{LibPQ.Result}","page":"API","title":"LibPQ.status","text":"status(jl_result::Result) -> libpq_c.ExecStatusType\n\nReturn the status of a result's corresponding database query according to libpq.\n\nSee also: error_message\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Base.close-Tuple{LibPQ.Result}","page":"API","title":"Base.close","text":"close(jl_result::Result)\n\nClean up the memory used by the PGresult object. The Result will no longer be usable.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Base.isopen-Tuple{LibPQ.Result}","page":"API","title":"Base.isopen","text":"isopen(jl_result::Result)\n\nDetermine whether the given Result has been closed, i.e. whether the memory associated with the underlying PGresult object has been cleared.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LibPQ.num_rows-Tuple{LibPQ.Result}","page":"API","title":"LibPQ.num_rows","text":"num_rows(jl_result::Result) -> Int\n\nReturn the number of rows in the query result. This will be 0 if the query would never return data.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LibPQ.num_columns-Tuple{LibPQ.Result}","page":"API","title":"LibPQ.num_columns","text":"num_columns(jl_result::Result) -> Int\n\nReturn the number of columns in the query result. This will be 0 if the query would never return data.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LibPQ.num_affected_rows-Tuple{LibPQ.Result}","page":"API","title":"LibPQ.num_affected_rows","text":"num_affected_rows(jl_result::Result) -> Int\n\nReturn the number of rows affected by the command returning the result. This is useful for counting the rows affected by operations such as INSERT, UPDATE and DELETE that do not return rows but affect them. This will be 0 if the query does not affect any row.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Base.show-Tuple{IO, LibPQ.Result}","page":"API","title":"Base.show","text":"show(io::IO, jl_result::Result)\n\nShow a PostgreSQL result and whether it has been cleared.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Statements","page":"API","title":"Statements","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.Statement\nnum_columns(::LibPQ.Statement)\nnum_params(::LibPQ.Statement)\nBase.show(::IO, ::LibPQ.Statement)\nLibPQ.load!","category":"page"},{"location":"pages/api/#LibPQ.Statement","page":"API","title":"LibPQ.Statement","text":"struct Statement\n\nA PostgreSQL prepared statement\n\nFields:\n\njl_conn::LibPQ.Connection\nA Connection for which this statement is valid. It may become invalid if the connection is reset.\n\nname::String\nAn autogenerated name for the prepared statement (using unique_id\nquery::String\nThe query string of the prepared statement\ndescription::LibPQ.Result\nA Result containing a description of the prepared statement\nnum_params::Int64\nThe number of parameters accepted by this statement according to description\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.num_columns-Tuple{LibPQ.Statement}","page":"API","title":"LibPQ.num_columns","text":"num_columns(stmt::Statement) -> Int\n\nReturn the number of columns that would be returned by executing the prepared statement.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LibPQ.num_params-Tuple{LibPQ.Statement}","page":"API","title":"LibPQ.num_params","text":"num_params(stmt::Statement) -> Int\n\nReturn the number of parameters in the prepared statement.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Base.show-Tuple{IO, LibPQ.Statement}","page":"API","title":"Base.show","text":"show(io::IO, jl_result::Statement)\n\nShow a PostgreSQL prepared statement and its query.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LibPQ.load!","page":"API","title":"LibPQ.load!","text":"LibPQ.load!(table, connection::LibPQ.Connection, query) -> LibPQ.Statement\n\nInsert the data from table using query. query will be prepared as a LibPQ.Statement and then execute is run on every row of table.\n\nFor best performance, wrap the call to this function in a PostgreSQL transaction:\n\njulia> execute(conn, \"BEGIN;\");\n\njulia> LibPQ.load!(\n           (no_nulls = [\"foo\", \"baz\"], yes_nulls = [\"bar\", missing]),\n           conn,\n           \"INSERT INTO libpqjl_test (no_nulls, yes_nulls) VALUES (\\$1, \\$2);\",\n       );\n\njulia> execute(conn, \"COMMIT;\");\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#Copy","page":"API","title":"Copy","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.CopyIn\nexecute(::LibPQ.Connection, ::LibPQ.CopyIn)","category":"page"},{"location":"pages/api/#LibPQ.CopyIn","page":"API","title":"LibPQ.CopyIn","text":"struct CopyIn\n\nCopyIn(query, data_itr) -> CopyIn\n\nCreate a CopyIn query instance which can be executed to send data to PostgreSQL via a COPY <table_name> FROM STDIN query.\n\nquery must be a COPY FROM STDIN query as described in the PostgreSQL documentation. COPY FROM queries which use a file or PROGRAM source can instead use the standard execute query interface.\n\ndata_itr is an iterable containing chunks of data to send to PostgreSQL. The data can be divided up into arbitrary buffers as it will be reconstituted on the server. The iterated items must be AbstractStrings or Array{UInt8}s.\n\nFields:\n\nquery::String\ndata_itr::Any\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.execute-Tuple{LibPQ.Connection, LibPQ.CopyIn}","page":"API","title":"LibPQ.execute","text":"execute(jl_conn::Connection, copyin::CopyIn, args...;\n    throw_error::Bool=true, kwargs...\n) -> Result\n\nRuns execute on copyin's query, then sends copyin's data to the server.\n\nAll other arguments are passed through to the execute call for the initial query.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Asynchronous","page":"API","title":"Asynchronous","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"async_execute\nLibPQ.AsyncResult\ncancel","category":"page"},{"location":"pages/api/#LibPQ.async_execute","page":"API","title":"LibPQ.async_execute","text":"async_execute(\n    jl_conn::Connection,\n    query::AbstractString,\n    [parameters::Union{AbstractVector, Tuple},]\n    binary_format::Bool=false,\n    kwargs...\n) -> AsyncResult\n\nRun a query on the PostgreSQL database and return an AsyncResult.\n\nThe AsyncResult contains a Task which processes a query asynchronously. Calling fetch on the AsyncResult will return a Result.\n\nAll keyword arguments are the same as execute and are passed to the created Result.\n\nOnly one AsyncResult can be active on a Connection at once. If multiple AsyncResults use the same Connection, they will execute serially.\n\nasync_execute does not yet support Statements.\n\nasync_execute optionally takes a parameters vector which passes query parameters as strings to PostgreSQL.\n\nbinary_format, when set to true, will transfer the data in binary format. Support for binary transfer is currently limited to a subset of basic data types.\n\nQueries without parameters can contain multiple SQL statements, and the result of the final statement is returned. Any errors which occur during executed statements will be bundled together in a CompositeException and thrown.\n\nAs is normal for Tasks, any exceptions will be thrown when calling wait or fetch.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.AsyncResult","page":"API","title":"LibPQ.AsyncResult","text":"An asynchronous PostgreSQL query\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.cancel","page":"API","title":"LibPQ.cancel","text":"cancel(async_result::AsyncResult)\n\nIf this AsyncResult represents a currently-executing query, attempt to cancel it.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#Internals","page":"API","title":"Internals","text":"","category":"section"},{"location":"pages/api/#Connections-2","page":"API","title":"Connections","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.handle_new_connection\nLibPQ.server_version\nLibPQ.encoding\nLibPQ.set_encoding!\nLibPQ.reset_encoding!\nLibPQ.transaction_status\nLibPQ.unique_id\nLibPQ.error_message(::LibPQ.Connection)","category":"page"},{"location":"pages/api/#LibPQ.handle_new_connection","page":"API","title":"LibPQ.handle_new_connection","text":"handle_new_connection(jl_conn::Connection; throw_error=true) -> Connection\n\nCheck status and handle errors for newly-created connections. Also set the client encoding (23.3. Character Set Support) to jl_conn.encoding.\n\nIf throw_error is true, an error will be thrown if the connection's status is CONNECTION_BAD and the PGconn object will be cleaned up. Otherwise, a warning will be shown and the user should call close or reset! on the returned Connection.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.server_version","page":"API","title":"LibPQ.server_version","text":"server_version(jl_conn::Connection) -> VersionNumber\n\nGet the PostgreSQL version of the server.\n\nSee 33.2. Connection Status Functions for information on the integer returned by PQserverVersion that is parsed by this function.\n\nSee @pqv_str for information on how this packages represents PostgreSQL version numbers.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.encoding","page":"API","title":"LibPQ.encoding","text":"encoding(jl_conn::Connection) -> String\n\nReturn the client encoding name for the current connection (see Table 23.1. PostgreSQL Character Sets for possible values).\n\nCurrently all Julia connections are set to use UTF8 as this makes conversion to and from String straightforward.\n\nSee also: set_encoding!, reset_encoding!\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.set_encoding!","page":"API","title":"LibPQ.set_encoding!","text":"set_encoding!(jl_conn::Connection, encoding::String)\n\nSet the client encoding for the current connection (see Table 23.1. PostgreSQL Character Sets for possible values).\n\nCurrently all Julia connections are set to use UTF8 as this makes conversion to and from String straighforward. Other encodings are not explicitly handled by this package and will probably be very buggy.\n\nSee also: encoding, reset_encoding!\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.reset_encoding!","page":"API","title":"LibPQ.reset_encoding!","text":"reset_encoding!(jl_conn::Connection, encoding::String)\n\nReset the client encoding for the current connection to jl_conn.encoding.\n\nSee also: encoding, set_encoding!\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.transaction_status","page":"API","title":"LibPQ.transaction_status","text":"transaction_status(jl_conn::Connection) -> libpq_c.PGTransactionStatusType\n\nReturn the PostgreSQL database server's current in-transaction status for the connection. See  for information on the meaning of the possible return values.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.unique_id","page":"API","title":"LibPQ.unique_id","text":"unique_id(jl_conn::Connection, prefix::AbstractString=\"\") -> String\n\nReturn a valid PostgreSQL identifier that is unique for the current connection. This is mostly used to create names for prepared statements.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.error_message-Tuple{LibPQ.Connection}","page":"API","title":"LibPQ.error_message","text":"error_message(jl_conn::Connection) -> String\n\nReturn the error message most recently generated by an operation on the connection. Includes a trailing newline.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Connection-Info","page":"API","title":"Connection Info","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.ConnectionOption\nLibPQ.conninfo\nLibPQ.ConninfoDisplay\nBase.parse(::Type{LibPQ.ConninfoDisplay}, ::AbstractString)","category":"page"},{"location":"pages/api/#LibPQ.ConnectionOption","page":"API","title":"LibPQ.ConnectionOption","text":"struct ConnectionOption\n\nA Julia representation of a PostgreSQL connection option (PQconninfoOption).\n\nFields:\n\nkeyword::String\nThe name of the option\nenvvar::Union{Missing, String}\nThe name of the fallback environment variable for this option\ncompiled::Union{Missing, String}\nThe PostgreSQL compiled-in default for this option\nval::Union{Missing, String}\nThe value of the option if set\nlabel::String\nThe label of the option for display\ndisptype::LibPQ.ConninfoDisplay\nIndicator for how to display the option (see ConninfoDisplay)\ndispsize::Int64\nThe size of field to provide for entry of the option value (not used here)\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.conninfo","page":"API","title":"LibPQ.conninfo","text":"conninfo(jl_conn::Connection) -> Vector{ConnectionOption}\n\nGet all connection options for a connection.\n\n\n\n\n\nconninfo(str::AbstractString) -> Vector{ConnectionOption}\n\nParse connection options from a connection string (either a URI or key-value pairs).\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.ConninfoDisplay","page":"API","title":"LibPQ.ConninfoDisplay","text":"primitive type ConninfoDisplay <: Enum{Int32} 32\n\nIndicator for how to display a PostgreSQL connection option (PQconninfoOption).\n\nPossible values are:\n\nNormal (libpq: \"\"): display as is\nPassword (libpq: \"*\"): hide the value of this field\nDebug (libpq: \"D\"): don't show by default\n\nFields:\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#Base.parse-Tuple{Type{LibPQ.ConninfoDisplay}, AbstractString}","page":"API","title":"Base.parse","text":"parse(::Type{ConninfoDisplay}, str::AbstractString) -> ConninfoDisplay\n\nParse a ConninfoDisplay from a string. See ConninfoDisplay.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Results-and-Statements","page":"API","title":"Results and Statements","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.handle_result\nLibPQ.column_name\nLibPQ.column_names\nLibPQ.column_number\nLibPQ.column_oids\nLibPQ.column_types\nLibPQ.num_params(::LibPQ.Result)\nLibPQ.error_message(::LibPQ.Result)","category":"page"},{"location":"pages/api/#LibPQ.handle_result","page":"API","title":"LibPQ.handle_result","text":"handle_result(jl_result::Result; throw_error::Bool=true) -> Result\n\nCheck status and handle errors for newly-created result objects.\n\nIf throw_error is true, throw an error and clear the result if the query results in a fatal error or unreadable response. Otherwise a warning is shown.\n\nAlso print an info message about the result.\n\n\n\n\n\nhandle_result(async_result::AsyncResult; throw_error=true) -> Result\n\nExecutes the query in async_result and waits for results.\n\nThis implements the loop described in the PostgreSQL documentation for Asynchronous Command Processing.\n\nThe throw_error option only determines whether to throw errors when handling the new Results; the Task may error for other reasons related to processing the asynchronous loop.\n\nThe result returned will be the Result of the last query run (the only query if using parameters). Any errors produced by the queries will be thrown together in a CompositeException.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.column_name","page":"API","title":"LibPQ.column_name","text":"column_name(jl_result::Result, column_number::Integer) -> String\n\nReturn the name of the column at index column_number (1-based).\n\n\n\n\n\ncolumn_name(stmt::Statement, column_number::Integer) -> String\n\nReturn the name of the column at index column_number (1-based) that would be returned by executing the prepared statement.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.column_names","page":"API","title":"LibPQ.column_names","text":"column_names(jl_result::Result) -> Vector{String}\n\nReturn the names of all the columns in the query result.\n\n\n\n\n\ncolumn_names(stmt::Statement) -> Vector{String}\n\nReturn the names of all the columns in the query result that would be returned by executing the prepared statement.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.column_number","page":"API","title":"LibPQ.column_number","text":"column_number(jl_result::Result, column_name::Union{AbstractString, Symbol}) -> Int\n\nReturn the index (1-based) of the column named column_name.\n\n\n\n\n\ncolumn_number(jl_result::Result, column_idx::Integer) -> Int\n\nReturn the index of the column if it is valid, or error.\n\n\n\n\n\ncolumn_number(stmt::Statement, column_name::AbstractString) -> Int\n\nReturn the index (1-based) of the column named column_name that would be returned by executing the prepared statement.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.column_oids","page":"API","title":"LibPQ.column_oids","text":"column_oids(jl_result::Result) -> Vector{LibPQ.Oid}\n\nReturn the PostgreSQL oids for each column in the result.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.column_types","page":"API","title":"LibPQ.column_types","text":"column_types(jl_result::Result) -> Vector{Type}\n\nReturn the corresponding Julia types for each column in the result.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.num_params-Tuple{LibPQ.Result}","page":"API","title":"LibPQ.num_params","text":"num_params(jl_result::Result) -> Int\n\nReturn the number of parameters in a prepared statement. If this result did not come from the description of a prepared statement, return 0.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LibPQ.error_message-Tuple{LibPQ.Result}","page":"API","title":"LibPQ.error_message","text":"error_message(jl_result::Result; verbose=false) -> String\n\nReturn the error message associated with the result, or an empty string if there was no error. If verbose, have libpq generate a more verbose version of the error message if possible. Includes a trailing newline.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Errors","page":"API","title":"Errors","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"using InteractiveUtils\nusing TikzGraphs\nusing TikzPictures\nusing LightGraphs\nusing LibPQ\n\nfunction dograph()\n    g = SimpleDiGraph()\n    types = Any[LibPQ.Errors.LibPQException]\n\n    i = 1\n    add_vertex!(g)\n    while i <= length(types)\n        curr_length = length(types)\n        typ = types[i]\n        subtyps = subtypes(typ)\n        for (j, subtyp) in enumerate(subtyps)\n            push!(types, subtyp)\n            add_vertex!(g)\n            add_edge!(g, i, curr_length + j)\n        end\n        i += 1\n    end\n\n    TikzGraphs.plot(\n        g,\n        map(String∘nameof, types),\n        node_style=\"draw, rounded corners\",\n        node_styles=Dict(enumerate((isabstracttype(t) ? \"fill=blue!10\" : \"fill=green!10\") for t in types)),\n    )\nend\n\nTikzPictures.save(SVG(\"error_types\"), dograph())\n\nnothing","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"<div style=\"text-align:center\">\n    <figure>\n        <img src=\"error_types.svg\" alt=\"Exception Type Hierarchy\">\n        <figcaption>LibPQ Exception Type Hierarchy<figcaption>\n    </figure>\n</div>","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.Errors.LibPQException\nLibPQ.Errors.JLClientException\nLibPQ.Errors.PostgreSQLException\nLibPQ.Errors.JLConnectionError\nLibPQ.Errors.JLResultError\nLibPQ.Errors.ConninfoParseError\nLibPQ.Errors.PQConnectionError\nLibPQ.Errors.PQResultError","category":"page"},{"location":"pages/api/#LibPQ.Errors.LibPQException","page":"API","title":"LibPQ.Errors.LibPQException","text":"Base abstract type for all custom exceptions thrown by LibPQ.jl\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.Errors.JLClientException","page":"API","title":"LibPQ.Errors.JLClientException","text":"An exception generated by LibPQ.jl\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.Errors.PostgreSQLException","page":"API","title":"LibPQ.Errors.PostgreSQLException","text":"An exception with an error message generated by PostgreSQL\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.Errors.JLConnectionError","page":"API","title":"LibPQ.Errors.JLConnectionError","text":"An error regarding a connection generated by LibPQ.jl\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.Errors.JLResultError","page":"API","title":"LibPQ.Errors.JLResultError","text":"An error regarding a query result generated by LibPQ.jl\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.Errors.ConninfoParseError","page":"API","title":"LibPQ.Errors.ConninfoParseError","text":"An error from parsing connection parameter strings reported by PostgreSQL\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.Errors.PQConnectionError","page":"API","title":"LibPQ.Errors.PQConnectionError","text":"An error regarding a connection reported by PostgreSQL\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.Errors.PQResultError","page":"API","title":"LibPQ.Errors.PQResultError","text":"An error regarding a query result generated by PostgreSQL\n\nThe Code parameter represents the PostgreSQL error code as defined in Appendix A. PostgreSQL Error Codes. The Class parameter is the first two characters of that code, also listed on that page.\n\nFor a list of all error aliases, see src/error_codes.jl, which was generated using the PostgreSQL documentation linked above.\n\njulia> try execute(conn, \"SELORCT NUUL;\") catch err println(err) end\nLibPQ.Errors.SyntaxError(\"ERROR:  syntax error at or near \\\"SELORCT\\\"\\nLINE 1: SELORCT NUUL;\\n        ^\\n\")\n\njulia> LibPQ.Errors.SyntaxError\nLibPQ.Errors.PQResultError{LibPQ.Errors.C42, LibPQ.Errors.E42601}\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#Type-Conversions","page":"API","title":"Type Conversions","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.oid\nLibPQ.PQChar\nLibPQ.PQ_SYSTEM_TYPES\nLibPQ.PQTypeMap\nBase.getindex(::LibPQ.PQTypeMap, typ)\nBase.setindex!(::LibPQ.PQTypeMap, ::Type, typ)\nLibPQ._DEFAULT_TYPE_MAP\nLibPQ.LIBPQ_TYPE_MAP\nLibPQ.PQConversions\nBase.getindex(::LibPQ.PQConversions, oid_typ::Tuple{Any, Type})\nBase.setindex!(::LibPQ.PQConversions, ::Base.Callable, oid_typ::Tuple{Any, Type})\nLibPQ._DEFAULT_CONVERSIONS\nLibPQ.LIBPQ_CONVERSIONS\nLibPQ._FALLBACK_CONVERSION","category":"page"},{"location":"pages/api/#LibPQ.oid","page":"API","title":"LibPQ.oid","text":"oid(typ::Union{Symbol, String, Integer}) -> LibPQ.Oid\n\nConvert a PostgreSQL type from an AbstractString or Symbol representation to its oid representation. Integers are converted directly to LibPQ.Oids.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.PQChar","page":"API","title":"LibPQ.PQChar","text":"primitive type PQChar 8\n\nA one-byte character type for correspondence with PostgreSQL's one-byte \"char\" type.\n\nFields:\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.PQ_SYSTEM_TYPES","page":"API","title":"LibPQ.PQ_SYSTEM_TYPES","text":"const PQ_SYSTEM_TYPES::Dict{Symbol, Oid}\n\nInternal mapping of PostgreSQL's default types from PostgreSQL internal name to Oid. The names may not correspond well to the common names, e.g., \"char(n)\" is :bpchar. This dictionary is generated with the deps/system_type_map.jl script and contains only PostgreSQL's system-defined types. It is expected (but might not be guaranteed) that these are the same across versions and installations.\n\n\n\n\n\n","category":"constant"},{"location":"pages/api/#LibPQ.PQTypeMap","page":"API","title":"LibPQ.PQTypeMap","text":"struct PQTypeMap <: AbstractDict{UInt32, Type}\n\nA mapping from PostgreSQL Oid to Julia type.\n\nFields:\n\ntype_map::Dict{UInt32, Type}\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#Base.getindex-Tuple{LibPQ.PQTypeMap, Any}","page":"API","title":"Base.getindex","text":"Base.getindex(tmap::PQTypeMap, typ) -> Type\n\nGet the Julia type corresponding to the given PostgreSQL type (any type accepted by oid) according to tmap.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Base.setindex!-Tuple{LibPQ.PQTypeMap, Type, Any}","page":"API","title":"Base.setindex!","text":"Base.setindex!(tmap::PQTypeMap, val::Type, typ)\n\nSet the Julia type corresponding to the given PostgreSQL type (any type accepted by oid) in tmap.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LibPQ._DEFAULT_TYPE_MAP","page":"API","title":"LibPQ._DEFAULT_TYPE_MAP","text":"const _DEFAULT_TYPE_MAP::PQTypeMap\n\nThe PQTypeMap containing the default type mappings for LibPQ.jl. This should not be mutated; LibPQ-level type mappings can be added to LIBPQ_TYPE_MAP.\n\n\n\n\n\n","category":"constant"},{"location":"pages/api/#LibPQ.LIBPQ_TYPE_MAP","page":"API","title":"LibPQ.LIBPQ_TYPE_MAP","text":"const LIBPQ_TYPE_MAP::PQTypeMap\n\nThe PQTypeMap containing LibPQ-level type mappings for LibPQ.jl. Adding type mappings to this constant will override the default type mappings for all code using LibPQ.jl.\n\n\n\n\n\n","category":"constant"},{"location":"pages/api/#LibPQ.PQConversions","page":"API","title":"LibPQ.PQConversions","text":"struct PQConversions <: AbstractDict{Tuple{UInt32, Type}, Union{Function, Type}}\n\nA mapping from Oid and Julia type pairs to the function for converting a PostgreSQL value with said Oid to said Julia type.\n\nFields:\n\nfunc_map::Dict{Tuple{UInt32, Type}, Union{Function, Type}}\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#Base.getindex-Tuple{LibPQ.PQConversions, Tuple{Any, Type}}","page":"API","title":"Base.getindex","text":"Base.getindex(cmap::PQConversions, oid_typ::Tuple{Any, Type}) -> Base.Callable\n\nGet the function according to cmap for converting a PostgreSQL value of some PostgreSQL type (any type accepted by oid) to some Julia type.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Base.setindex!-Tuple{LibPQ.PQConversions, Union{Function, Type}, Tuple{Any, Type}}","page":"API","title":"Base.setindex!","text":"Base.setindex!(cmap::PQConversions, val::Base.Callable, oid_typ::Tuple{Any, Type})\n\nSet the function in cmap for converting a PostgreSQL value of some PostgreSQL type (any type accepted by oid) to some Julia type.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LibPQ._DEFAULT_CONVERSIONS","page":"API","title":"LibPQ._DEFAULT_CONVERSIONS","text":"const _DEFAULT_CONVERSIONS::PQConversions\n\nThe PQConversions containing the default conversion functions for LibPQ.jl. This should not be mutated; LibPQ-level conversion functions can be added to LIBPQ_CONVERSIONS.\n\n\n\n\n\n","category":"constant"},{"location":"pages/api/#LibPQ.LIBPQ_CONVERSIONS","page":"API","title":"LibPQ.LIBPQ_CONVERSIONS","text":"const LIBPQ_CONVERSIONS::PQConversions\n\nThe PQConversions containing LibPQ-level conversion functions for LibPQ.jl. Adding conversions to this constant will override the default conversions for all code using LibPQ.jl.\n\n\n\n\n\n","category":"constant"},{"location":"pages/api/#LibPQ._FALLBACK_CONVERSION","page":"API","title":"LibPQ._FALLBACK_CONVERSION","text":"A fallback conversion mapping (like PQConversions which holds a single function for converting PostgreSQL data of a given Oid to a given Julia type, using the parse function.\n\n\n\n\n\n","category":"constant"},{"location":"pages/api/#Parsing","page":"API","title":"Parsing","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.PQValue\nLibPQ.data_pointer\nLibPQ.num_bytes\nBase.unsafe_string(::LibPQ.PQValue)\nLibPQ.string_view\nLibPQ.bytes_view\nBase.parse(::Type{Any}, pqv::LibPQ.PQValue)","category":"page"},{"location":"pages/api/#LibPQ.PQValue","page":"API","title":"LibPQ.PQValue","text":"A wrapper for one value in a PostgreSQL result.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#LibPQ.data_pointer","page":"API","title":"LibPQ.data_pointer","text":"data_pointer(pqv::PQValue) -> Ptr{UInt8}\n\nGet a raw pointer to the data for one value in a PostgreSQL result. This data will be freed by libpq when the result is cleared, and should only be used temporarily.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.num_bytes","page":"API","title":"LibPQ.num_bytes","text":"num_bytes(pqv::PQValue) -> Cint\n\nThe length in bytes of the PQValue's corresponding data. When a query uses LibPQ.TEXT format, this is equivalent to C's strlen.\n\nSee also: data_pointer\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#Base.unsafe_string-Tuple{LibPQ.PQValue}","page":"API","title":"Base.unsafe_string","text":"unsafe_string(pqv::PQValue) -> String\n\nConstruct a String from a PQValue by copying the data.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LibPQ.string_view","page":"API","title":"LibPQ.string_view","text":"string_view(pqv::PQValue) -> String\n\nWrap a PQValue's underlying data in a String. This function uses data_pointer and num_bytes and does not copy.\n\nnote: Note\nThe underlying data will be freed by libpq when the result is cleared, and should only be used temporarily.\n\nSee also: bytes_view\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.bytes_view","page":"API","title":"LibPQ.bytes_view","text":"bytes_view(pqv::PQValue) -> Vector{UInt8}\n\nWrap a PQValue's underlying data in a vector of bytes. This function uses data_pointer and num_bytes and does not copy.\n\nThis function differs from string_view as it keeps the \u0000 byte at the end. PQValue parsing functions should use bytes_view when the data returned by PostgreSQL is not in UTF-8.\n\nnote: Note\nThe underlying data will be freed by libpq when the result is cleared, and should only be used temporarily.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#Base.parse-Tuple{Type{Any}, LibPQ.PQValue}","page":"API","title":"Base.parse","text":"parse(::Type{T}, pqv::PQValue) -> T\n\nParse a value of type T from a PQValue. By default, this uses any existing parse method for parsing a value of type T from a String.\n\nYou can implement default PostgreSQL-specific parsing for a given type by overriding pqparse.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Miscellaneous","page":"API","title":"Miscellaneous","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"LibPQ.@pqv_str\nLibPQ.string_parameters\nLibPQ.parameter_pointers\nLibPQ.unsafe_string_or_null","category":"page"},{"location":"pages/api/#LibPQ.@pqv_str","page":"API","title":"LibPQ.@pqv_str","text":"@pqv_str -> VersionNumber\n\nParse a PostgreSQL version.\n\nnote: Note\nAs of version 10.0, PostgreSQL moved from a three-part version number (where the first two parts represent the major version and the third represents the minor version) to a two-part major-minor version number. In LibPQ.jl, we represent this using the first two VersionNumber components as the major version and the third as the minor version.Examplesjulia> using LibPQ: @pqv_str\n\njulia> pqv\"10.1\" == v\"10.0.1\"\ntrue\n\njulia> pqv\"9.2.5\" == v\"9.2.5\"\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"pages/api/#LibPQ.string_parameters","page":"API","title":"LibPQ.string_parameters","text":"string_parameters(parameters::AbstractVector) -> Vector{Union{String, Missing}}\n\nConvert parameters to strings which can be passed to libpq, propagating missing.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.parameter_pointers","page":"API","title":"LibPQ.parameter_pointers","text":"parameter_pointers(parameters::AbstractVector{<:Parameter}) -> Vector{Ptr{UInt8}}\n\nGiven a vector of parameters, returns a vector of pointers to either the string bytes in the original or C_NULL if the element is missing.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#LibPQ.unsafe_string_or_null","page":"API","title":"LibPQ.unsafe_string_or_null","text":"unsafe_string_or_null(ptr::Cstring) -> Union{String, Missing}\n\nConvert a Cstring to a Union{String, Missing}, returning missing if the pointer is C_NULL.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/","page":"API","title":"API","text":"DocTestSetup = nothing","category":"page"},{"location":"pages/type-conversions/#typeconv","page":"Type Conversions","title":"Type Conversions","text":"","category":"section"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"The implementation of type conversions across the LibPQ.jl interface is sufficiently complicated that it warrants its own section in the documentation. Luckily, it should be easy to use for whichever case you need.","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"DocTestSetup = quote\n    using LibPQ\n    using DataFrames\n    using Tables\n\n    DATABASE_USER = get(ENV, \"LIBPQJL_DATABASE_USER\", \"postgres\")\n    conn = LibPQ.Connection(\"dbname=postgres user=$DATABASE_USER\")\nend","category":"page"},{"location":"pages/type-conversions/#From-Julia-to-PostgreSQL","page":"Type Conversions","title":"From Julia to PostgreSQL","text":"","category":"section"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"Currently all types are printed to strings and given to LibPQ as such, with no special treatment. Expect this to change in a future release. For now, you can convert the data to strings yourself before passing to execute. This should only be necessary for data types whose Julia string representation is not valid in PostgreSQL, such as arrays.","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"julia> A = collect(12:15);\n\njulia> nt = columntable(execute(conn, \"SELECT \\$1 = ANY(\\$2) AS result\", Any[13, string(\"{\", join(A, \",\"), \"}\")]));\n\njulia> nt[:result][1]\ntrue","category":"page"},{"location":"pages/type-conversions/#From-PostgreSQL-to-Julia","page":"Type Conversions","title":"From PostgreSQL to Julia","text":"","category":"section"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"The default type conversions applied when fetching PostgreSQL data should be sufficient in many cases.","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"julia> df = DataFrame(execute(conn, \"SELECT 1::int4, 'foo'::varchar, '{1.0, 2.1, 3.3}'::float8[], false, TIMESTAMP '2004-10-19 10:23:54'\"))\n1×5 DataFrames.DataFrame\n│ Row │ int4 │ varchar │ float8          │ bool  │ timestamp           │\n├─────┼──────┼─────────┼─────────────────┼───────┼─────────────────────┤\n│ 1   │ 1    │ foo     │ [1.0, 2.1, 3.3] │ false │ 2004-10-19T10:23:54 │","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"The column types in Julia for the above DataFrame are Int32, String, Vector{Float64}, Bool, and DateTime.","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"Any unknown or unsupported types are parsed as Strings by default.","category":"page"},{"location":"pages/type-conversions/#NULL","page":"Type Conversions","title":"NULL","text":"","category":"section"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"The PostgreSQL NULL is handled with missing. By default, data streamed using the Tables interface is Union{T, Missing}, and columns are Vector{Union{T, Missing}}. While libpq does not provide an interface for checking whether a result column contains NULL, it's possible to assert that columns do not contain NULL using the not_null keyword argument to execute. This will result in data retrieved as T/Vector{T} instead. not_null accepts a list of column names or column positions, or a Bool asserting that all columns do or do not have the possibility of NULL.","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"The type-related interfaces described below only deal with the T part of the Union{T, Missing}, and there is currently no way to use an alternate NULL representation.","category":"page"},{"location":"pages/type-conversions/#Overrides","page":"Type Conversions","title":"Overrides","text":"","category":"section"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"It's possible to override the default type conversion behaviour in several places. Refer to the Implementation section for more detailed information.","category":"page"},{"location":"pages/type-conversions/#Query-level","page":"Type Conversions","title":"Query-level","text":"","category":"section"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"There are three arguments to execute for this:","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"column_types argument to set the desired types for given columns. This is accepted as a dictionary mapping column names (as Symbols or Strings) and/or positions (as Integers) to Julia types.\ntype_map argument to set the mapping from PostgreSQL types to Julia types. This is accepted as a dictionary mapping PostgreSQL oids (as Integers) or canonical type names (as Symbols or Strings) to Julia types.\nconversions argument to set the function used to convert from a given PostgreSQL type to a given Julia type. This is accepted as a dictionary mapping 2-tuples of PostgreSQL oids or type names (as above) and Julia types to callables (functions or type constructors).","category":"page"},{"location":"pages/type-conversions/#Connection-level","page":"Type Conversions","title":"Connection-level","text":"","category":"section"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"LibPQ.Connection supports type_map and conversions arguments as well, which will apply to all queries run with the created connection. Query-level overrides will override connection-level overrides.","category":"page"},{"location":"pages/type-conversions/#Global","page":"Type Conversions","title":"Global","text":"","category":"section"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"To override behaviour for every query everywhere, add mappings to the global constants LibPQ.LIBPQ_TYPE_MAP and LibPQ.LIBPQ_CONVERSIONS. Connection-level overrides will override these global overrides.","category":"page"},{"location":"pages/type-conversions/#Implementation","page":"Type Conversions","title":"Implementation","text":"","category":"section"},{"location":"pages/type-conversions/#Flow","page":"Type Conversions","title":"Flow","text":"","category":"section"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"When a LibPQ.Result is created (as the result of running a query), the Julia types and conversion functions for each column are precalculated and stored within the Result. The types are chosen using these sources, in decreasing priority:","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"column_types overrides at Result level\ntype_map overrides at Result level\ntype_map overrides at Connection level\nLibPQ.LIBPQ_TYPE_MAP\nLibPQ._DEFAULT_TYPE_MAP\nfallback to String","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"Using those types, the function for converting from PostgreSQL data to Julia data is selected, using these sources, in decreasing priority:","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"conversions overrides at Result level\nconversions overrides at Connection level\nLibPQ.LIBPQ_CONVERSIONS\nLibPQ._DEFAULT_CONVERSIONS,\nfallback to parse","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"When fetching a particular value from a Result, that function is used to turn data wrapped by a PQValue to a Julia type. This operation always copies or parses data and never provides a view into the original Result.","category":"page"},{"location":"pages/type-conversions/#canon","page":"Type Conversions","title":"Canonical PostgreSQL Type Names","text":"","category":"section"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"While PostgreSQL allows many aliases for its types (e.g., double precision for float8 and character varying for varchar), there is one \"canonical\" name for the type stored in the pg_type table from PostgreSQL's catalog. You can find a list of these for all of PostgreSQL's default types in the keys of LibPQ.PQ_SYSTEM_TYPES.","category":"page"},{"location":"pages/type-conversions/","page":"Type Conversions","title":"Type Conversions","text":"DocTestSetup = nothing","category":"page"},{"location":"pages/faq/#Frequently-Asked-Questions","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"pages/faq/#Can-I-use-LibPQ.jl-with-Amazon-Redshift?","page":"FAQ","title":"Can I use LibPQ.jl with Amazon Redshift?","text":"","category":"section"},{"location":"pages/faq/","page":"FAQ","title":"FAQ","text":"Yes. However, LibPQ.jl by default sets some client options to make interactions more reliable. Unsupported options must be disabled for Redshift to allow connections. To override all options, pass an empty Dict{String, String}:","category":"page"},{"location":"pages/faq/","page":"FAQ","title":"FAQ","text":"conn = LibPQ.Connection(\"dbname=myredshift\"; options=Dict{String, String}())","category":"page"},{"location":"pages/faq/#How-do-I-test-LibPQ.jl-on-my-own-computer?","page":"FAQ","title":"How do I test LibPQ.jl on my own computer?","text":"","category":"section"},{"location":"pages/faq/","page":"FAQ","title":"FAQ","text":"To test LibPQ.jl you will need access to a PostgreSQL database server with a database called \"postgres\". The tests will not make any changes to the database that persist beyond the connection session, even if the tests encounter unforeseen exceptions. For this reason, it should be safe to use any existing database server. To set the database user used to connect to the database, use the LIBPQJL_DATABASE_USER environment variable.","category":"page"},{"location":"pages/faq/","page":"FAQ","title":"FAQ","text":"A simple way to set up a server for testing is to use Docker:","category":"page"},{"location":"pages/faq/","page":"FAQ","title":"FAQ","text":"docker run --detach --name test-libpqjl -e POSTGRES_HOST_AUTH_METHOD=trust -p 5432:5432 postgres","category":"page"},{"location":"pages/faq/","page":"FAQ","title":"FAQ","text":"To set any other client options for connecting to the test database, use the PostgreSQL environment variables. You will likely need to set PGHOST=localhost to connect using the TCP socket instead of the UNIX domain socket.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: LibPQ.jl Logo)","category":"page"},{"location":"#LibPQ","page":"Home","title":"LibPQ","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia wrapper for the PostgreSQL libpq C library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: In Development) (Image: Build Status) (Image: CodeCov)","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Selection","page":"Home","title":"Selection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using LibPQ, Tables\n\nconn = LibPQ.Connection(\"dbname=postgres\")\nresult = execute(conn, \"SELECT typname FROM pg_type WHERE oid = 16\")\ndata = columntable(result)\n\n# the same but with parameters\nresult = execute(conn, \"SELECT typname FROM pg_type WHERE oid = \\$1\", [\"16\"])\ndata = columntable(result)\n\n# the same but asynchronously\nasync_result = async_execute(conn, \"SELECT typname FROM pg_type WHERE oid = \\$1\", [\"16\"])\n# do other things\nresult = fetch(async_result)\ndata = columntable(result)\n\nclose(conn)","category":"page"},{"location":"#Insertion","page":"Home","title":"Insertion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using LibPQ\n\nconn = LibPQ.Connection(\"dbname=postgres user=$DATABASE_USER\")\n\nresult = execute(conn, \"\"\"\n    CREATE TEMPORARY TABLE libpqjl_test (\n        no_nulls    varchar(10) PRIMARY KEY,\n        yes_nulls   varchar(10)\n    );\n\"\"\")\n\nLibPQ.load!(\n    (no_nulls = [\"foo\", \"baz\"], yes_nulls = [\"bar\", missing]),\n    conn,\n    \"INSERT INTO libpqjl_test (no_nulls, yes_nulls) VALUES (\\$1, \\$2);\",\n)\n\nclose(conn)","category":"page"},{"location":"#A-Note-on-Bulk-Insertion","page":"Home","title":"A Note on Bulk Insertion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When inserting a large number of rows, wrapping your insert queries in a transaction will greatly increase performance. See the PostgreSQL documentation 14.4.1. Disable Autocommit for more information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Concretely, this means surrounding your query like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"execute(conn, \"BEGIN;\")\n\nLibPQ.load!(\n    (no_nulls = [\"foo\", \"baz\"], yes_nulls = [\"bar\", missing]),\n    conn,\n    \"INSERT INTO libpqjl_test (no_nulls, yes_nulls) VALUES (\\$1, \\$2);\",\n)\n\nexecute(conn, \"COMMIT;\")","category":"page"},{"location":"#COPY","page":"Home","title":"COPY","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An alternative to repeated INSERT queries is the PostgreSQL COPY query. LibPQ.CopyIn makes it easier to stream data to the server using a COPY FROM STDIN query.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LibPQ, DataFrames\n\nconn = LibPQ.Connection(\"dbname=postgres user=$DATABASE_USER\")\n\nrow_strings = imap(eachrow(df)) do row\n    if ismissing(row[:yes_nulls])\n        \"$(row[:no_nulls]),\\n\"\n    else\n        \"$(row[:no_nulls]),$(row[:yes_nulls])\\n\"\n    end\nend\n\ncopyin = LibPQ.CopyIn(\"COPY libpqjl_test FROM STDIN (FORMAT CSV);\", row_strings)\n\nexecute(conn, copyin)\n\nclose(conn)","category":"page"}]
}
